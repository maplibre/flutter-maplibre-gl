// This file is generated by
// ./scripts/lib/generate.dart

import MapLibre

class LayerPropertyConverter {
{{#layerTypes}}
    class func add{{typePascal}}Properties({{typeCamel}}Layer: MLN{{typePascal}}StyleLayer, properties: [String: String]) {
        for (propertyName, propertyValue) in properties {
            // Check if the value is explicitly null to clear the property
            let trimmedValue = propertyValue.trimmingCharacters(in: .whitespaces)
            
            // Prepare expression: nil for "null", parsed for valid values, skip for invalid
            var expression: NSExpression?
            if trimmedValue == "null" {
                expression = nil
            } else {
                guard let expr = interpretExpression(propertyName: propertyName, expression: propertyValue) else {
                    continue
                }
                expression = expr
            }
            
            switch propertyName {
                {{#paint_properties}}
                case "{{{value}}}":
                {{#isIosAsCamelCase}}
                    {{typeCamel}}Layer.{{iosAsCamelCase}} = expression
                {{/isIosAsCamelCase}}
                {{^isIosAsCamelCase}}
                    {{typeCamel}}Layer.{{valueAsCamelCase}} = expression
                {{/isIosAsCamelCase}}
                {{/paint_properties}}
                {{#layout_properties}}
                case "{{{value}}}":
                {{^isVisibilityProperty}}
                {{#isIosAsCamelCase}}
                    {{typeCamel}}Layer.{{iosAsCamelCase}} = expression
                {{/isIosAsCamelCase}}
                {{^isIosAsCamelCase}}
                    {{typeCamel}}Layer.{{valueAsCamelCase}} = expression
                {{/isIosAsCamelCase}}
                {{/isVisibilityProperty}}
                {{#isVisibilityProperty}}
                    if trimmedValue != "null" {
                        let trimmedPropertyValue = propertyValue.trimmingCharacters(in: .init(charactersIn: "\""))
                        {{typeCamel}}Layer.{{iosAsCamelCase}} = trimmedPropertyValue == "visible"
                    }
                {{/isVisibilityProperty}}
                {{/layout_properties}}
             
                default:
                    break
            }
        }
    }

{{/layerTypes}}
    private class func interpretExpression(propertyName: String, expression: String) -> NSExpression? {
        let isColor = propertyName.contains("color");
        let isOffset = propertyName.contains("offset");
        let isTranslate = propertyName.contains("translate");

        do {
            let json = try JSONSerialization.jsonObject(with: expression.data(using: .utf8)!, options: .fragmentsAllowed)
            
            // Check if JSON contains NSNull - this would create an invalid NSExpression
            if json is NSNull {
                return nil
            }
            
            // this is required because NSExpression.init(mglJSONObject: json) fails to create
            // a proper Expression if the data of is a hexString
            if isColor {
                if let color = json as? String {
                    return NSExpression(forConstantValue: UIColor(hexString: color))
                }
            }

            if let offset = json as? [Any]{
                // checks on the value of property that are literal expressions
                if offset.count == 2 && offset.first is String && offset.first as? String == "literal" {
                    if let vector = offset.last as? [Any]{
                        if(vector.count == 2) {
                            if isOffset || isTranslate {
                                // this is required because NSExpression.init(mglJSONObject: json) fails to create
                                // a proper Expression if the data of a literal is an array destined for a CGVector
                                if let x = vector.first as? Double, let y = vector.last as? Double {
                                    return NSExpression(forConstantValue: NSValue(cgVector: CGVector(dx: x, dy: y)))
                                }
                            }
                            return NSExpression.init(mglJSONObject: json)
                        }
                    }
                // checks on the value of properties that are arrays
                } else if offset.count == 2, let x = offset.first as? Double, let y = offset.last as? Double {
                    if isOffset || isTranslate {
                        // this is required because NSExpression.init(mglJSONObject: json) fails to create
                        // a proper Expression if the data of an array is destined for a CGVector
                        return NSExpression(forConstantValue: NSValue(cgVector: CGVector(dx: x, dy: y)))
                    }
                    // this is required because NSExpression.init(mglJSONObject: json) fails to create
                    // a proper Expression if the data is an array of double
                    return NSExpression(forConstantValue: [NSNumber(value: x), NSNumber(value: y)])
                } else {
                    // Handle arrays with any number of elements (e.g., dash arrays with 3+ elements)
                    // Convert to array of NSNumbers for proper expression creation
                    let numbers = offset.compactMap { $0 as? Double }.map { NSNumber(value: $0) }
                    if numbers.count == offset.count {
                        return NSExpression(forConstantValue: numbers)
                    }
                }
            }
            
            return NSExpression.init(mglJSONObject: json)
        } catch {
        }
        return nil
    }
}
